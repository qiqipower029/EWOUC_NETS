---
title: "EWOUC-NETS"
author: "Jieqi Tu"
date: "10/11/2020"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

Define a function of MCMC to update parameters.
```{r define functions}
# Likelihood function
likelihood<-function(rho0_t, rho0_e, gamma_t, gamma_e, theta_t, theta_e, phi, simdata){
  
  beta0_t = logit(rho0_t)   #calculate beta0 for likelihood
  beta1_t = (logit(theta_t)-logit(rho0_t))/gamma_t  #calculate beta1 for likelihood
  beta0_e = logit(rho0_e)   #calculate beta0 for likelihood
  beta1_e = (logit(theta_e)-logit(rho0_e))/gamma_e  #calculate beta1 for likelihood
  
  s = simdata$S    # NETS of recent patients.
  y = simdata$Y    # Efficacy of recent patients. y = 1 if efficacy event occurs.
  
  # Calculate the probability of toxicity given dose = x
  pit = exp(beta0_t + beta1_t * simdata$X)/(1+exp(beta0_t + beta1_t * simdata$X))
  
  # Calculate the probability of efficacy given dose = x
  pie = exp(beta0_e + beta1_e * simdata$X)/(1+exp(beta0_e + beta1_e * simdata$X))
  
  # Define marginal probabilities
  pi11 = pit*pie*(1+((exp(phi)-1)/(exp(phi)+1))*(1-pit)*(1-pie))
  pi10 = pie - pi11
  pi01 = pit - pi11
  pi00 = 1 - pi11 - pi10 - pi01
  
  # Calculate the joint quasi likelihood of all recent patients
  likelihood = prod((pi11^(s*y))*(pi01^(y*(1-s)))*(pi10^((1-y)*s))*(pi00^((1-y)*(1-s))))  
  
  return(likelihood)
}

### Update phi ###
phi_up = function(rho0_t, rho0_e, gamma_t, gamma_e, theta_t, theta_e, prephi, simdata) {
  # the range of phi is negative infinity to infinity, so we need transformation of phi
  z = rnorm(1, 0, 1)
  phi_new = log(z/(1-z)) # range from -inf to inf with equally distributed probability
  
  lik_phi_new = likelihood(rho0_t, rho0_e, gamma_t, gamma_e, theta_t, theta_e, phi_new, simdata)
  lik_phi_old = likelihood(rho0_t, rho0_e, gamma_t, gamma_e, theta_t, theta_e, prephi, simdata)
  
  ratio_phi = lik_phi_new/lik_phi_old
  if(ratio_phi=="NaN"){ratio_phi = 1}
  
  if(ratio_phi>=1){phi_next = phi_new}
  else{test<-runif(1)
  if(test<ratio_phi){phi_next = phi_new}
  else{phi_next<-prephi}
  
  }
  return(phi_next)
}

### Update rho0t ###
rho0t_up<-function(prerho0t, rho0_e, gamma_t, gamma_e, theta_t, theta_e, phi, simdata){
  rho0t_new<-runif(1,0,theta_t) #randomly select new value for rho0t
  
  lik_rhot_new<-likelihood(rho0t_new, rho0_e, gamma_t, gamma_e, theta_t, theta_e, phi, simdata=simdata)
  lik_rhot_old<-likelihood(prerho0t,rho0_e, gamma_t, gamma_e, theta_t, theta_e, phi, simdata=simdata)
  
  ratio_rhot<-lik_rhot_new/lik_rhot_old
  
  if(ratio_rhot=="NaN"){ratio_rhot<-1}
  
  if(ratio_rhot>=1){rhot_next<-rho0t_new}
  else{test<-runif(1)
  if(test<ratio_rhot){rhot_next<-rho0t_new}
  else{rhot_next<-prerho0t}
  
  }
  return(rhot_next)
}

### Update rho0e ###
rho0e_up<-function(rho0_t, prerho0e, gamma_t, gamma_e, theta_t, theta_e, phi, simdata){
  delta = 0.001 # Small positive number
  rho0e_new<-runif(1,0,theta_t+delta) #randomly select new value for rho0e
  
  lik_rhoe_new<-likelihood(rho0_t, rho0e_new, gamma_t, gamma_e, theta_t, theta_e, phi, simdata=simdata)
  lik_rhoe_old<-likelihood(rho0_t, prerho0e, gamma_t, gamma_e, theta_t, theta_e, phi, simdata=simdata)
  
  ratio_rhoe<-lik_rhoe_new/lik_rhoe_old
  
  if(ratio_rhoe=="NaN"){ratio_rhoe<-1}
  
  if(ratio_rhoe>=1){rhoe_next<-rho0e_new}
  else{test<-runif(1)
  if(test<ratio_rhoe){rhoe_next<-rho0e_new}
  else{rhoe_next<-prerho0e}
  
  }
  return(rhoe_next)
}


# Update gammat #
gammat_up<-function(posrho0,pregamma,theta,simdata){
  gamma_new<-runif(1,0,1)
  
  lik_gamma_new<-likelihood(posrho0,gamma_new,theta,simdata=simdata)
  lik_gamma_old<-likelihood(posrho0,pregamma,theta,simdata=simdata)
  ratio_gamma<-lik_gamma_new/lik_gamma_old
  
  if(ratio_gamma=="NaN"){ratio_gamma<-1}
  if(ratio_gamma>=1){gamma_next<-gamma_new}
  else{
    test<-runif(1)
    if(test<ratio_gamma){gamma_next<-gamma_new}
    else{gamma_next<-pregamma}
  }
  return(gamma_next)
}


posterior<-function(orirho0,origamma,theta,simdata,int){
  # create variables to store updated rho0 and gamma values.
  rho0_s<-c(orirho0,rep(NA,int-1))
  gamma_s<-c(origamma,rep(NA,int-1))
  
  #First update rho0 based on input data and assume gamma is known 
  for(i1 in 2:int){
    rho0_s[i1]<-rho0_up(rho0_s[i1-1],origamma,theta,simdata=simdata)
  }
  
  #Second update gamma based on input data and 
  #assume rho0 (bayesian estimator) known
  b <- median(rho0_s[25000:30000])
  for(i2 in 2:int){
    gamma_s[i2]<-gamma_up(b,gamma_s[i2-1],theta,simdata=simdata)
  }
  
  posterior<-list(rho0_s,gamma_s)
  return(posterior)
  
}

```

